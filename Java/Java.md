# JAVA

## 8/31

## JVM / JRE / JDK

* ### JVM (Java Virtual Machine)

  * #### 자바 컴파일러를 통해 생성된 Class(byte code) 파일을 기계어로 해석하고 실행시켜준다.

* ### JRE (Java Runtime Environment)

  * #### 사용자를 위한 도구이다. (사용자는 JDK까지 사용할 필요가 없다.)

  * #### JVM을 포함하고 있다.

  * #### JRE가 설치되어 있어야 플랫폼에 독립적일 수 있다.

  * #### 자바 코드를 받아서 필요한 라이브러리와 결합한 다음 이 코드를 실행할 JVM을 시작한다.

* ### JDK (Java Development Kit)

  * #### 개발자를 위한 도구이다.

  * #### JRE를 포함하고 있다. 

* ### 플랫폼에 독립적

  * #### Window에서 컴파일 된 클래스파일 (byte code)을 JRE를 통해 리눅스에도 실행이 가능하다.

  * #### 어느 환경에서나 그 환경에 맞는 JVM만 설치되어 있다면 프로그램 실행이 가능하다.



##  9/1

## 클래스

### 객체

* #### 객체는 속성과 동작으로 이루어져 있으며 속성과 동작은 각각 필드와 메서드라고 한다

### 객체 지향 프로그래밍의 특징

* #### 캡슐화

* #### 상속

* #### 다형성



### 필드

* #### 필드는 생성자와 모든 메소드에서 사용이 가능하다.

### 생성자

* #### 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

* #### 기본생성자가 반드시 존재한다.

### 메서드

* #### 메소드는 객체간의 데이터 전달의 수단으로 사용된다.

### static (정적 멤버 선언)

* #### 인스턴스 객체에 소속된 멤버가 아니라 클래스에 소속된 멤버이다.

* #### 정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이다.

* #### 객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적필드로 선언하는 것이 좋다.

### final 필드

* #### final 필드는 초기값이 저장되면 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다.

### 상수

* #### 상수는 static이면서 final이어야 한다.

* **static final 타입 상수 = 초기값;**

* #### 상수 이름은 대문자로 작성하는 것이 관례이다.

### 접근 제한자

* #### public

  * ##### 모든 패키지, 클래스에서 사용 가능하다.

* #### protected

  * ##### 접근 불가 : 자식 클래스가 아닌 다른 패키지에 소속된 클래스

* #### default

  * ##### public을 생략했다면 클래스는  default 접근제한을 가진다.

  * ##### 같은 패키지는 제한 없이 사용 가능하지만 다른 패키지에서는 사용할 수 없다.

  * ##### 접근 불가 : 다른패키지에 소속된 클래스

* #### private

  * ##### 접근 불가 : 모든 외부 클래스

  * ##### 필드를 외부로부터 보호하고, 필드에 대한 getter setter 메소드를 이용하여 필드 값을 안전하게 조회/ 변경한다.

  * ##### private 접근 제한을 갖는 필드와 메서드는 상속 대상에서 제한 된다.

### Getter

* #### 필드 값을 조회할 수 있는 메서드

### Setter

* #### 필요한 필드의 값을 설정하는  메서드



## 9/2

## 상속

### 클래스 상속

* #### class 자식 클래스 expends 부모 클래스{ }

* #### 다중 상속을 허용하지 않는다. 

### 부모 생성자 호출 super()

* #### super( )은 부모의 기본 생성자를 호출한다.

* #### super(매개값)은 매개값과 일치하는 부모 생성자를 호출한다.

* #### 부모 클래스에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자  호출을 위해 super(매개값)를 명시적으로 호출해야 한다.

* #### super()은 반드시 자식 생성자 첫 줄에 위치해야 한다.



## Overloading , Override

* ### Overloading (다중 정의)

  1. #### 메소드를 같은 클래스에서 정의한다.

  2. #### 메소드 이름이 동일하다.

  3. #### Parameter 갯수나 데이터 타입이 반드시 달라야 한다.

* ### Overriding (재정의)

  1. #### 메소드를 하위 클래스에서 정의한다.

  2. #### 메소드 이름이 동일하다.

  3. #### Parameter 갯수나 데이터 타입이 동일하다.

  4. #### return 타입이 동일하다.

  5. #### 접근제한자 : 하위 메소드의 접근 범위가 상위 메소드의 접근 범위 보다 넓거나 같아야 한다.

### 다형성

* **다양한 형태를 가짐**
* **여러개의 자식 클래스를 하나의 부모 타입으로 통일시킨다.**
* **같은 타입이지만 여러 객체를 이용해 실행 결과가 다양하게 나올 수 있다.**
* **객체의 부품화가 가능하다.**
* **부모 클래스로 타입 변화가 가능하다.**

### 자동 타입 변환

* #### 자식은 부모와 동일하게 취급될 수 있다.

* #### 부모타입 변수(ex) animal) = new  자식 타입(); // 자식 타입 변수(ex) cat) = new 자식타입

* #### animal == cat은 true 이다.

* #### 이렇게 생성된 변수는 자식 객체를 참조한다.

### 강제 타입 변환 (Casting)

* #### 강제 타입 변환은 부모 타입을 자식 타입으로 변환하는 것을 말한다.

* #### 자식 클래스 변수 = (자식 클래스) 부모클래스 타입

* #### 부모 타입에 선언된 필드와 메소드만 사용하는 건 제약 사항이 따르기 때문에 사용 된다.



### 추상클래스

* **추상 : 공통되는 특성을 추출한 것 ex) 새, 고양이, 강아지는 동물이다.**

* **추상 클래스는 스스로 객체를 생성할 수 없다.** **
*  **new연산자를 사용해 인스턴스를 생성할 수 없다.**     **//Employee emp = new Employee() (x)**
* **자식 클래스가 super(매개값)을 호출해서 추상클래스 객체를 생성하므로 추상클래스도 생성자가 반드시 있어야 한다.**
* **객체를 직접 생성할 수 있는 클래스를 실체 클래스라고 한다.**
* **실체 클래스의 공통 특성을 추출해서 선언한 클래스가 추상 클래스이다.**
* **추상 클래스와 실체 클래스는 상속 관계이며 실체 클래스는 추상클래스의 모든 특성을 물려 받는다.**



* **추상클래스는 abstract 키워드를 붙여야 한다.**

 * **자식 클래스를 부모 타입으로 선언 할 수 있다.**
 * **부모타입  변수 = new 자식타입() (o) //자동 타입 변환** 
 * **abstract method(body가 없는 메서드)도 선언할 수 있고,** 
 * **concrete method도(body가 있는 메서드) 선언할 수 있다**

### 추상 메소드와 오버라이딩

* #### 자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩) 해서 실행 내용을 작성해야 한다.

* #### 메소드의 선언부만 있고 메소드 싱행 내용인 중괄호가 없는 메소드를 말한다.

* **public abstract 리턴타입 메소드명(매개변수);**

* **추상 클래스를 Animal로 예를 들어 동물의 울음소리를 나타내자면**
* **먼저 Animal 추상 클래스의 abstract sound() 메소드를 정의한다**
* **Dog 클래스에서는 sound() 메소드를 오버라이딩 해서 "멍멍" Cat 클래스에서는 sound()메소드를 오버라이딩 해서 "야옹"**
* 

### 인터페이스 

1. **완벽한 추상화 달성**
2. **다중 상속 기능 지원**
3. **다형성 사용**



### Colection

* **객체를 저장할 때마다 크기를 자동으로 늘려준다.**
* **Set 계열 : 중복을 허용하지 않고, 추가되는 순서를 유지하지 않는다.**
* **LIst 계열 : 중복을 허용하고, 추가되는 순서를 유지한다.**
* **Map 계열  : 키와 값의 쌍으로 저장 된다. (키와 값 모두 객체여야 한다.)**
* **java.util package에 있다.**



### 자료구조

* #### Stack

  * **Stack 클래스는 LIFO(후입선출) 자료구조를 구현한 클래스이다.**
  * `Stack<E> stack = new Stack<E>()`
  * **Stack의 메소드로는** 
    * **push(E item) : 주어진 객체를 스택에 넣는다**
    * **peek() : 스택의 맨 위 객체(가장 마지막에 저장된 객체)를 가져온다. 객체를 스택에서 제거하지 않는다.**
    * **pop() : 스택의 맨 위객체를 가져온다. 객체를 스택에서 제거한다.**

* #### Query

  * **Query 인터페이스는 FIFO(선입선출) 자료구조에서 사용되는 메소드를 정의하고 있다.**
  * `Queue<E> queue = new LinkedList<E>()`
  * **Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList 이다.**
  * **Queue의 메소드로는**
    * **offer(E e) : 주어진 객체를 넣는다.**
    * **peek() : 객체 하나를 가져온다. 객체를 큐에서 제거하지 않는다.**
    * **poll() : 객체 하나를 가져온다. 객체를 큐에서 제거한다.**



### 람다식

* 자바스크립트의 화살표함수와 비슷하다.
* 함수형 인터페이스를 람다식으로 이용할 수 있다.
* 람다식을 사용하기 위해서 함수형 인터페이스는 추상메소드가 한 개만 있어야만 한다.
  * 하나만 매칭이 되여야 하기 때문이다.

```java
public class LambdaTest {
	public static void main(String[] args) {
		List<String> asList = Arrays.asList("자바","람다","부트");
		//1단계 : MyConsumer 클래스 생성 전달
		asList.forEach(new MyConumer());
		
		//2단계 : Consumer를 anonymous inner class로 생성해서 accept 메서드를 오버라이딩하기
		asList.forEach(new Consumer<String>() {

			@Override
			public void accept(String t) {
				System.out.println(t);
			}
		});
		System.out.println("람다식으로 메서드 오버라이딩");
		//3단계 : Consumer의 accept() 메서드 오버라이딩을 람다식으로 사용하기
		asList.forEach(value -> System.out.println(value));
		
		//4단계 : Consumer의 accept() 메서드 오버라이딩을 Method Reference로 사용하기
		System.out.println("Method Reference");
		asList.forEach(System.out::println);
	}
}
class MyConumer implements Consumer<String>{

	@Override
	public void accept(String t) {
		System.out.println(t);
	}
	
}
```

