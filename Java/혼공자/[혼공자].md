## 자바 프로그램 개발 과정

#### 소스 코드가 실행되는 과정 (간단하게)

* 자바 소스 파일 (.java)를 작성하고 저장한다.

* 자바 컴파일러가 (javac) 소스 파일을 컴파일하고 바이트 코드 파일을 (.class) 생성한다. 

  * > 컴파일러 : 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 프로그램

* JVM이 바이트 코드를 기계어로 번역하고 실행한다.

* 이 과정을 통해 개발자는 운영체제에 종속되지 않고 개발이 가능하다.



#### Java 버전별 특징

**Java SE 8**

* lambda 표현식 추가
* interface **default** method
* interface **static** method
  * 이전 버전에서는 상수와 추상메소드만 사용할 수 있었다.
* Optional (null이 될 수 있는 객체를 감싸는 래퍼 클래스)
  * 저장된 값이 null이면 NoSuchElementException 예외가 발생
  * Optional을 사용하는 이유
    * 존재할 수도 있지만 존재하지 않을 수도 있는 객체 즉, null이 될 수도 있는 객체를 감싸고 있는 일종의 래퍼 클래스입니다.
    * null을 검사하는 방법이 있지만 굳이 Optional을 사용하는 이유가 뭘까
    * 계속되는 null처리를 직접 처리하지 않고 optionall클래스에 위임하기 위함입니다

##### Java SE9

* interface **private** method
* 이후 64비트 버전만 출시

**Java SE 10**

* 병렬 처리 가비지 컬렉션
* **var 키워드**를 이용한 **지역변수 선언** 및 타입추론 가능

**Java SE 11**

* lambda 파라미터에 대한 지역변수 문법

  * ```java
    (var x, var y) -> x.process(y)
    (x,y) -> x.process(y)
    ```

**Java SE 12**

**Java SE 13**



## 변수와 타입

#### 변수

> 변수는 **값을 저장할 수 있는 메모리**의 **특정 번지**에 붙이는 이름입니다.
>
> 프로그램은 변수를 통해 메모리의 특정 번지애 값을 저장하고 읽을 수 있습니다.

#### 변수 이름

* 첫 글자는 글자이거나 '$', '_' 이어야 합니다.

* 영어 대소문자를 구분합니다.

* 문자 길이의 제한은 없습니다.

* 자바 예약어는 사용할 수 없습니다.

  * ex) Type, class 등등..

  

#### 기본 타입

> 정수, 실수, 논리 값을 저장할 수 있다.

|   구분    | 저장되는 값에 따른 분류 | 타입의 종류                      |
| :-------: | ----------------------- | -------------------------------- |
| 기본 타입 | 정수 타입               | byte < char < short < int < long |
| 기본 타입 | 실수 타입               | float, double                    |
| 기본 타입 | 논리 타입               | boolean                          |

#### 정수 타입

##### 정수 타입의 메모리 사용 크기

* **byte** (1byte) < **shor** (2byte) < **char** (2byte) < **int** (4byte) < **long** (8byte)

##### Long 타입 사용시

* **int 타입의 허용 범위** (-2,147,483,648 ~ 2,147,483,648) 를 **초과할 경우**, long 타입임을 컴파일러에게 알려주어야 합니다.

```java
long var1 = 100000000000; //컴파일 에러
long var2 = 100000000000L; //소문자 l이나 대문자 L 상관은 없지만 가독성을 위해 L을 사용한다.
long var3 = 100000; //허용 범위 안이라면 L을 사용하지 않아도 된다.
```

##### char 타입

> 하나의 작은 따옴표 (' ')로 감싼 것을 **문자 리터럴**이라고 합니다.
>
> 문자 리터럴은 **유니코드**로 변환되어 저장됩니다.
>
> 큰 따옴표 (" ")로 감싼 문자들을 **문자열**이라고 부릅니다.
>
> 작은 따옴표와 큰 따옴표는 컴파일러가 문자 리터럴과 문자열 리터럴을 구별하는 기호로 사용됩니다.

##### 이스케이프 문자

> **문자열 내부**에 **역슬래시** (`\`)가 붙은 문자를 사용할 수 있다.

| 이스케이프 문자 | 출력 용도          |
| --------------- | ------------------ |
| \t              | 탭만큼 띄움 (수평) |
| \n              | 줄 바꿈 (수직)     |
| `\`"            | " 출력             |
| `\`'            | ' 출력             |
| `\\`            | \ 출력             |



#### 실수 타입

##### 실수 타입의 메모리 사용 크기

* **float** (4byte) (소수점 이하 7자리) < **double** (8byte) (소수점 이하 15자리) 



#### 타입 변환

##### 자동 타입변환

> 값의 허용 범위가 **작은 타입이** 허용 범위가 **큰 타입으로 저장**될 때 발생합니다.

```java
byte byteValue = 10;
int intvalue = byteValue 
```

> 실수 타입은 정수 타입보다 허용 범위가 더 큽니다.

```java
long longValue = 5000000000L;
float floatValue = longValue;
double doubleValue = floatValue;
```



##### 강제 타입 변환

> 값의 허용 범위가 큰 타입은 작은 허용 범위의 타입으로 자동타입할 수 없습니다.
>
> 예를들어 큰 그릇의 물을 작을 컵으로 옮기는 것과 같은 이치입니다.
>
> 하지만 여러 컵에 나누어 담을 수는 있습니다.
>
> 강제 타입 변환은 **캐스팅 연산자 괄호()**를 사용합니다.

```java
int intValue = 10;
byte byteValue = (byte) intValue //강제 타입 변환
```



## 연산자

##### 비트 연산자

```java
//& 연산자 (and)
//대응되는 두 비트가 모두 1일 때만 1을 반환하고, 다른 경우 0을 반환합니다.
0 0 0 0 1 1 1 1
& & & & & & & &
0 0 0 1 0 1 0 1
// 0 0 0 0 0 1 0 1 (5)

//| 연산자 (or)
//대응되는 두 비트 중 하나라도 1이면 1을 반환하며, 두 비트가 모두 0일 때만 0을 반환합니다.
0 0 0 0 1 1 1 1
| | | | | | | |
0 0 0 1 0 1 0 1
// 0 0 0 1 1 1 1 1 (31)
```

